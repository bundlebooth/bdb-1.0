name: Map and Deploy JSON to Cal.com

on:
  push:
    branches:
      - main
    paths:
      - 'packages.json'
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Verify packages.json
        run: |
          if [ ! -f packages.json ]; then
            echo "Error: packages.json not found"
            exit 1
          fi
          echo "packages.json verified"

      - name: Write utility functions
        run: |
          cat <<'SCRIPT' > utils.js
          const https = require('https');
          const fs = require('fs');

          function apiRequest(method, path, body = null) {
            return new Promise((resolve, reject) => {
              const options = {
                hostname: 'api.cal.com',
                path,
                method,
                headers: {
                  Authorization: `Bearer ${process.env.CALCOM_API_KEY}`,
                  'Content-Type': 'application/json'
                }
              };
              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => {
                  if (res.statusCode >= 200 && res.statusCode < 300) {
                    try {
                      resolve(JSON.parse(data || '{}'));
                    } catch (e) {
                      reject(new Error(`Failed to parse response for ${path}: ${e.message}`));
                    }
                  } else {
                    reject(new Error(`Request failed for ${path} with status ${res.statusCode}`));
                  }
                });
              });
              req.on('error', (e) => reject(new Error(`Request error for ${path}: ${e.message}`)));
              if (body) req.write(JSON.stringify(body));
              req.end();
            });
          }

          async function getAllEventTypes() {
            try {
              const res = await apiRequest('GET', '/api/v2/event-types');
              const eventTypes = Array.isArray(res) ? res :
                res.eventTypes && Array.isArray(res.eventTypes) ? res.eventTypes :
                res.event_types && Array.isArray(res.event_types) ? res.event_types :
                res.data && Array.isArray(res.data) ? res.data : [];
              if (!Array.isArray(eventTypes)) {
                throw new Error('Invalid event types response structure');
              }
              return eventTypes;
            } catch (e) {
              throw new Error(`Error fetching event types: ${e.message}`);
            }
          }

          function deduplicatePackages(packages) {
            const seenSlugs = new Set();
            return packages.filter(pkg => {
              if (seenSlugs.has(pkg.slug)) {
                console.warn(`Duplicate slug detected: ${pkg.slug}. Skipping package: ${pkg.name}`);
                return false;
              }
              seenSlugs.add(pkg.slug);
              return true;
            });
          }

          function loadPackages() {
            let packages = JSON.parse(fs.readFileSync('packages.json'));
            if (packages.some(pkg => Object.keys(pkg).length === 1)) {
              packages = packages.map(p => Object.values(p)[0]);
            }
            return deduplicatePackages(packages);
          }

          module.exports = { apiRequest, getAllEventTypes, deduplicatePackages, loadPackages };
          SCRIPT

      - name: Write event type deletion script
        run: |
          cat <<'SCRIPT' > delete-event-types.js
          const { apiRequest, getAllEventTypes } = require('./utils');

          async function deleteAllEventTypes() {
            try {
              const eventTypes = await getAllEventTypes();
              if (!eventTypes.length) {
                console.log('No event types found to delete');
                return;
              }
              for (const { id, slug } of eventTypes) {
                if (id) {
                  await apiRequest('DELETE', `/api/v2/event-types/${id}`);
                  console.log(`Deleted event type: ${slug || 'unknown'}`);
                } else {
                  console.warn(`Event type missing ID: ${JSON.stringify(eventTypes)}`);
                }
              }
              console.log('All event types processed for deletion');
            } catch (e) {
              console.error(`Fatal error during deletion: ${e.message}`);
              process.exit(1);
            }
          }

          deleteAllEventTypes();
          SCRIPT

      - name: Delete all event types
        env:
          CALCOM_API_KEY: ${{ secrets.CALCOM_API_KEY }}
        run: |
          node delete-event-types.js || {
            node delete-event-types.js || {
              node delete-event-types.js || {
                echo "Deletion script failed. Check logs for details."
                exit 1
              }
            }
          }

      - name: Write event type update script
        run: |
          cat <<'SCRIPT' > update-event-types.js
          const { apiRequest, getAllEventTypes, loadPackages } = require('./utils');

          const dayMap = {
            Monday: 'Monday', Tuesday: 'Tuesday', Wednesday: 'Wednesday',
            Thursday: 'Thursday', Friday: 'Friday', Saturday: 'Saturday', Sunday: 'Sunday',
            1: 'Monday', 2: 'Tuesday', 3: 'Wednesday', 4: 'Thursday', 5: 'Friday', 6: 'Saturday', 7: 'Sunday'
          };

          function compareObjects(obj1, obj2, path = '') {
            const differences = [];
            for (const key in obj1) {
              if (key === 'description' || key === 'scheduleIds') continue;
              const fullPath = path ? `${path}.${key}` : key;
              if (typeof obj1[key] === 'object' && obj1[key] && !Array.isArray(obj1[key])) {
                differences.push(...compareObjects(obj1[key], obj2[key] || {}, fullPath));
              } else if (Array.isArray(obj1[key])) {
                if (!Array.isArray(obj2[key]) || JSON.stringify(obj1[key]) !== JSON.stringify(obj2[key])) {
                  differences.push(`${fullPath}: ${JSON.stringify(obj1[key])} != ${JSON.stringify(obj2[key])}`);
                }
              } else if (obj1[key] !== obj2[key]) {
                differences.push(`${fullPath}: ${obj1[key]} != ${obj2[key]}`);
              }
            }
            for (const key in obj2) {
              if (!(key in obj1) && key !== 'id' && key !== 'description' && key !== 'scheduleIds') {
                differences.push(`${fullPath}: missing in new, present in old as ${obj2[key]}`);
              }
            }
            return differences;
          }

          function compareEventTypes(oldTypes, newTypes) {
            return {
              added: newTypes.filter(type => !oldTypes.includes(type)),
              deleted: oldTypes.filter(type => !newTypes.includes(type))
            };
          }

          async function updateEventTypes() {
            try {
              const packages = loadPackages();
              if (!packages.length) throw new Error('No valid packages found');
              const existingEventTypes = await getAllEventTypes();
              for (const pkg of packages) {
                if (!pkg.slug || !pkg.name) {
                  console.warn(`Invalid package: ${JSON.stringify(pkg)}`);
                  continue;
                }
                const priceText = pkg.discount > 0 
                  ? `**Price**: **$${pkg.price}** (Reg. ~~$${pkg.regPrice || pkg.regularPrice}~~) - ${pkg.discount}% OFF!`
                  : `**Price**: **$${pkg.price}**`;
                const servicesText = pkg.equipment && Array.isArray(pkg.equipment) && pkg.equipment.length > 0
                  ? `**Services Included**:\n${pkg.equipment.map(e => `- ${e}`).join('\n')}`
                  : `**Services Included**: None`;
                const description = [
                  priceText,
                  `**Description**: ${pkg.description || 'No description provided'}`,
                  `**Guests**: ${pkg.guests || 'Not specified'}`,
                  `**Duration**: Up to ${pkg.maxDuration || 3} hours`,
                  servicesText,
                  `**Note**: ${pkg.note || 'No additional notes'}`
                ].join('\n\n');
                const transformed = {
                  title: pkg.name,
                  slug: pkg.slug,
                  length: (pkg.maxDuration || 3) * 60,
                  description,
                  locations: pkg.locationTypes && Array.isArray(pkg.types) && pkg.types[0]?.location_type
                    ? [{ type: 'address', address: 'To be provided by client', public: true }]
                    : [{ type: 'address', address: pkg.type || 'Toronto, ON', public: true }],
                  availability: pkg.available || {
                    days: pkg.days || ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'],
                    startTime: pkg.start || '09:00',
                    endTime: pkg.end || '23:59'
                  },
                  tags: [
                    ...(Array.isArray(pkg.eventType) ? pkg.eventType : []),
                    ...(pkg.packageType ? [pkg.packageType] : []),
                    ...(pkg.Sale === 'Y' ? ['On Sale'] : []),
                    ...(pkg.New === 'Y' ? ['New'] : [])
                  ],
                  disableGuests: pkg.disableGuests || false,
                  metadata: {
                    disableCalVideoTranscription: pkg.disableCalVideoTranscript || false,
                    disableGuestsCancelling: pkg.disableGuestsCancel || false,
                    disableGuestsRescheduling: pkg.disableGuestsReschedule || false
                  },
                  bookingFields: pkg.bookingFields || [],
                  color: pkg.color,
                  minimumBookingNotice: pkg.minimumNotice,
                  bookerLayouts: pkg.bookerLayouts
                };
                const existingEventType = existingEventTypes.find(e => e.slug === pkg.slug);
                if (existingEventType) {
                  const differences = compareObjects(transformed, existingEventType);
                  const tagDiffs = compareEventTypes(existingEventType.tags || [], transformed.tags);
                  const updatePayload = { description };
                  if (differences.length || tagDiffs.added.length || tagDiffs.deleted.length) {
                    Object.assign(updatePayload, transformed);
                    await apiRequest('PATCH', `/api/v2/event-types/${existingEventType.id}`, updatePayload);
                    console.log(`Updated event type: ${pkg.slug}`);
                  } else {
                    await apiRequest('PATCH', `/api/v2/event-types/${existingEventType.id}`, updatePayload);
                    console.log(`Updated description for: ${pkg.slug}`);
                  }
                }
              }
              console.log('Event type updates completed');
            } catch (e) {
              console.error(`Fatal error during update: ${e.message}`);
              process.exit(1);
            }
          }

          updateEventTypes();
          SCRIPT

      - name: Update existing event types
        env:
          CALCOM_API_KEY: ${{ secrets.CALCOM_API_KEY }}
        run: |
          node update-event-types.js || {
            echo "Update script failed. Check logs for details."
            exit 1
          }

      - name: Write event type insertion script
        run: |
          cat <<'SCRIPT' > insert-event-types.js
          const { apiRequest, getAllEventTypes, loadPackages } = require('./utils');

          const dayMap = {
            Monday: 'Monday', Tuesday: 'Tuesday', Wednesday: 'Wednesday',
            Thursday: 'Thursday', Friday: 'Friday', Saturday: 'Saturday', Sunday: 'Sunday',
            1: 'Monday', 2: 'Tuesday', 3: 'Wednesday', 4: 'Thursday', 5: 'Friday', 6: 'Saturday', 7: 'Sunday'
          };

          async function createSchedule(scheduleData) {
            try {
              const payload = {
                name: scheduleData.name,
                timeZone: scheduleData.timeZone,
                isDefault: scheduleData.isDefault ?? true,
                availability: scheduleData.availability.map(slot => ({
                  ...slot,
                  days: slot.days.map(day => dayMap[day] || day)
                }))
              };
              const result = await apiRequest('POST', '/api/v2/schedules', payload);
              return result.data.id;
            } catch (e) {
              console.error(`Failed to create schedule: ${e.message}`);
              return null;
            }
          }

          async function insertNewEventTypes() {
            try {
              const packages = loadPackages();
              if (!packages.length) throw new Error('No valid packages found');
              const existingEventTypes = await getAllEventTypes();
              const existingSlugs = new Set(existingEventTypes.map(e => e.slug));
              for (const pkg of packages) {
                if (!pkg.slug || !pkg.name) {
                  console.warn(`Invalid package: ${JSON.stringify(pkg)}`);
                  continue;
                }
                if (existingSlugs.has(pkg.slug)) {
                  console.log(`Event type ${pkg.slug} already exists, skipping`);
                  continue;
                }
                const priceText = pkg.discount > 0 
                  ? `**Price**: **$${pkg.price}** (Reg. ~~$${pkg.regPrice || pkg.regularPrice}~~) - ${pkg.discount}% OFF!`
                  : `**Price**: **$${pkg.price}**`;
                const servicesText = pkg.equipment && Array.isArray(pkg.equipment) && pkg.equipment.length > 0
                  ? `**Services Offered**:\n${pkg.equipment.map(e => `- ${e}`).join('\n')}`
                  : `**Services Included**: None`;
                const description = [
                  priceText,
                  `**Description**: ${pkg.description || 'No description provided'}`,
                  `**Guests**: ${pkg.guests || 'Not specified'}`,
                  `**Duration**: Up to ${pkg.maxDuration || 3} hours`,
                  servicesText,
                  `**Note**: ${pkg.note || 'No additional notes'}`
                ].join('\n\n');
                const transformed = {
                  title: pkg.name,
                  slug: pkg.slug,
                  length: (pkg.maxDuration || 3) * 60,
                  description,
                  locations: pkg.locationTypes && Array.isArray(pkg.types) && pkg.types[0]?.location_type
                    ? [{ type: 'address', address: 'To be provided by client', public: true }]
                    : [{ type: 'address', address: pkg.type || 'Toronto, ON', public: true }],
                  availability: pkg.available || {
                    days: pkg.days || ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'],
                    startTime: pkg.startTime || '09:00',
                    endTime: pkg.endTime || '23:59'
                  },
                  tags: [
                    ...(Array.isArray(pkg.eventType) ? pkg.eventType : []),
                    ...(pkg.packageType ? [pkg.packageType] : []),
                    ...(pkg.Sale === 'Y' ? ['On Sale'] : []),
                    ...(pkg.New === 'Y' ? ['New'] : [])
                  ],
                  disableGuests: pkg.disableGuests || false,
                  metadata: {
                    disableCalVideoTranscription: pkg.disableCalVideo || false,
                    disableGuestsCancelling: pkg.disableGuestsCancel || false,
                    disableGuestsRescheduling: pkg.disableGuestsReschedule || false
                  },
                  bookingFields: pkg.fieldsFields || [],
                  color: pkg.color,
                  minimumBookingNotice: pkg.minimumNotice,
                  bookerLayouts: pkg.layouts
                };
                const result = await apiRequest('POST', '/api/v2/event-types', transformed);
                const eventTypeId = result.data.id;
                console.log(`Created event type: ${pkg.slug}`);
                if (transformed.availability && Array.isArray(transformed.availability.schedules)) {
                  const scheduleIds = [];
                  for (const schedule of transformed.availability.schedules) {
                    const scheduleId = await createSchedule(schedule);
                    if (scheduleId) scheduleIds.push(scheduleId);
                  }
                  if (scheduleIds.length) {
                    await apiRequest('PATCH', `/api/v2/event-types/${eventTypeId}`, { scheduleIds });
                    console.log(`Updated schedule IDs for: ${pkg.slug}`);
                  }
                }
                await new Promise(resolve => setTimeout(resolve, 5000));
              }
              console.log('Event type insertion completed');
            } catch (e) {
              console.error(`Fatal error during insertion: ${e.message}`);
              process.exit(1);
            }
          }

          insertNewEventTypes();
          SCRIPT

      - name: Insert new event types
        env:
          CALCOM_API_KEY: ${{ secrets.CALCOM_API_KEY }}
        run: |
          node insert-event-types.js || {
            echo "Insertion script failed. Check logs for details."
            exit 1
          }

      - name: Write payment configuration script
        run: |
          cat <<'SCRIPT' > configure-payments.js
          const { apiRequest, loadPackages } = require('./utils');

          async function getEventTypeId(slug) {
            try {
              const res = await apiRequest('GET', `/api/v2/event-types?slug=${encodeURIComponent(slug)}`);
              const eventTypes = Array.isArray(res) ? res :
                res.eventTypes && Array.isArray(res.eventTypes) ? res.eventTypes :
                res.event_types && Array.isArray(res.event_types) ? res.event_types :
                res.data && Array.isArray(res.data) ? res.data : [];
              return eventTypes.length ? eventTypes[0].id : null;
            } catch (e) {
              console.error(`Error fetching event type ID for ${slug}: ${e.message}`);
              return null;
            }
          }

          async function configurePayments() {
            try {
              const packages = loadPackages();
              for (const pkg of packages) {
                if (!pkg.slug || !pkg.name) {
                  console.warn(`Invalid package: ${JSON.stringify(pkg)}`);
                  continue;
                }
                if (!pkg.price || pkg.price <= 0) {
                  console.log(`Skipping payment for ${pkg.slug}: invalid price`);
                  continue;
                }
                const eventTypeId = await getEventTypeId(pkg.slug);
                if (!eventTypeId) {
                  console.warn(`No event type found for ${pkg.slug}`);
                  continue;
                }
                const paymentPayload = {
                  price: Math.round(pkg.price * 100),
                  currency: pkg.currency?.toLowerCase() || 'cad',
                  metadata: {
                    apps: {
                      stripe: {
                        enabled: true,
                        price: Math.round(pkg.price * 100),
                        currency: pkg.currency?.toLowerCase() || 'cad'
                      }
                    }
                  }
                };
                await apiRequest('PATCH', `/api/v2/event-types/${eventTypeId}`, paymentPayload);
                console.log(`Configured payment for: ${pkg.slug}`);
                await new Promise(resolve => setTimeout(resolve, 2000));
              }
              console.log('Payment configuration completed');
            } catch (e) {
              console.error(`Fatal error during payment configuration: ${e.message}`);
              process.exit(1);
            }
          }

          configurePayments();
          SCRIPT

      - name: Configure payments for event types
        env:
          CALCOM_API_KEY: ${{ secrets.CALCOM_API_KEY }}
        run: |
          node configure-payments.js || {
            echo "Payment configuration failed. Check logs for details."
            exit 1
          }

      - name: Archive logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deploy-logs
          path: |
            *.log
            *.txt
          retention-days: 7

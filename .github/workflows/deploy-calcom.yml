name: Map and Deploy JSON to Cal.com

on:
  push:
    branches:
      - main
    paths:
      - 'packages.json'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Map JSON and Push to Cal.com
        env:
          CALCOM_API_KEY: ${{ secrets.CALCOM_API_KEY }}
        run: |
          node <<EOF
            const fs = require('fs');
            const https = require('https');
            const dayMap = {
              'Monday': 1, 'Tuesday': 2, 'Wednesday': 3, 'Thursday': 4,
              'Friday': 5, 'Saturday': 6, 'Sunday': 7
            };
            function apiRequest(method, path, body = null) {
              return new Promise((resolve, reject) => {
                const options = {
                  hostname: 'api.cal.com',
                  path: path,
                  method: method,
                  headers: {
                    'Authorization': 'Bearer ' + process.env.CALCOM_API_KEY,
                    'Content-Type': 'application/json',
                    'cal-api-version': '2024-06-14'
                  }
                };
                const req = https.request(options, (res) => {
                  let data = '';
                  res.on('data', (chunk) => { data += chunk; });
                  res.on('end', () => {
                    if (res.statusCode >= 200 && res.statusCode < 300) {
                      try {
                        resolve(JSON.parse(data));
                      } catch (e) {
                        resolve({});
                      }
                    } else {
                      reject({ statusCode: res.statusCode, data: data });
                    }
                  });
                });
                req.on('error', (e) => { reject(e); });
                if (body) req.write(JSON.stringify(body));
                req.end();
              });
            }
            async function checkStripeConnectivity() {
              try {
                const res = await apiRequest('GET', '/v2/apps?slug=stripe');
                const apps = res.data || [];
                const stripeApp = apps.find(app => app.slug === 'stripe');
                if (!stripeApp || !stripeApp.enabled) {
                  console.error('Stripe is not enabled or connected in Cal.com. Please configure Stripe in Settings > Apps > Stripe.');
                  process.exit(1);
                }
                console.log('Stripe is connected and enabled.');
              } catch (e) {
                console.error('Error checking Stripe connectivity:', e);
                process.exit(1);
              }
            }
            async function getEventTypeId(slug) {
              try {
                const res = await apiRequest('GET', '/v2/event-types');
                const eventTypes = res.event_types || [];
                for (let i = 0; i < eventTypes.length; i++) {
                  if (eventTypes[i].slug === slug) {
                    return eventTypes[i].id;
                  }
                }
                return null;
              } catch (e) {
                console.error('Error fetching event types:', e);
                return null;
              }
            }
            async function deleteEventType(id) {
              try {
                await apiRequest('DELETE', '/v2/event-types/' + id);
                console.log('Deleted event type with ID: ' + id);
              } catch (e) {
                console.error('Error deleting event type with ID ' + id + ':', JSON.stringify(e.data || e.message, null, 2));
              }
            }
            async function processEvents() {
              try {
                console.log('Checking Stripe connectivity...');
                await checkStripeConnectivity();
                console.log('Reading packages.json...');
                let packages = JSON.parse(fs.readFileSync('packages.json'));
                if (packages.some(pkg => Object.keys(pkg).length === 1)) {
                  packages = packages.map(pkg => Object.values(pkg)[0]);
                }
                for (let i = 0; i < packages.length; i++) {
                  const pkg = packages[i];
                  if (!pkg.slug || !pkg.name) {
                    console.error('Invalid package: missing slug or name', JSON.stringify(pkg, null, 2));
                    process.exit(1);
                  }
                  console.log('Processing package: ' + pkg.slug);
                  const transformed = {
                    title: pkg.name || 'Placeholder Title',
                    slug: pkg.slug || 'placeholder',
                    lengthInMinutes: pkg.maxDuration ? pkg.maxDuration * 60 : 180,
                    description: pkg.description || 'No description provided',
                    locations: [
                      pkg.location === 'Online' 
                        ? { type: 'integration', integration: 'cal-video' }
                        : { type: 'address', address: pkg.location || 'Toronto, ON', public: true }
                    ],
                    availability: {
                      days: pkg.availabilityDays
                        ? pkg.availabilityDays.map(day => dayMap[day] || 1)
                        : [1, 2, 3, 4, 5],
                      startTime: pkg.startTime || '09:00',
                      endTime: pkg.endTime || '17:00'
                    },
                    tags: [],
                    metadata: {},
                    price: pkg.price && pkg.price > 0 ? Math.round(pkg.price * 100) : 0,
                    currency: pkg.currency?.toLowerCase() || 'cad'
                  };
                  if (Array.isArray(pkg.eventType)) {
                    transformed.tags = transformed.tags.concat(pkg.eventType);
                  }
                  if (pkg.packageType) transformed.tags.push(pkg.packageType);
                  if (pkg.Sale === 'Y') transformed.tags.push('On Sale');
                  if (pkg.New === 'Y') transformed.tags.push('New');
                  // Add Stripe configuration to metadata if price is present
                  if (pkg.price && pkg.price > 0) {
                    const currency = pkg.currency?.toLowerCase() || 'cad';
                    const supportedCurrencies = ['cad', 'usd', 'eur', 'gbp'];
                    if (!supportedCurrencies.includes(currency)) {
                      console.warn(`Unsupported currency '${currency}' for ${pkg.slug}, defaulting to 'cad'`);
                      transformed.currency = 'cad';
                      transformed.metadata = {
                        apps: {
                          stripe: {
                            enabled: true,
                            price: Math.round(pkg.price * 100),
                            currency: 'cad'
                          }
                        }
                      };
                    } else {
                      transformed.metadata = {
                        apps: {
                          stripe: {
                            enabled: true,
                            price: Math.round(pkg.price * 100),
                            currency: currency
                          }
                        }
                      };
                    }
                    console.log('Stripe configuration added for ' + pkg.slug + ':', JSON.stringify(transformed.metadata, null, 2));
                  } else {
                    console.log('No payment required for ' + pkg.slug);
                  }
                  console.log('Request payload for ' + pkg.slug + ':', JSON.stringify(transformed, null, 2));
                  const existingEventTypeId = await getEventTypeId(transformed.slug);
                  let method = existingEventTypeId ? 'PATCH' : 'POST';
                  let path = existingEventTypeId ? '/v2/event-types/' + existingEventTypeId : '/v2/event-types';
                  try {
                    const result = await apiRequest(method, path, transformed);
                    console.log('Success for ' + transformed.slug + ':', JSON.stringify(result, null, 2));
                    // Verify if Stripe metadata was applied
                    if (pkg.price && pkg.price > 0 && (!result.data.metadata?.apps?.stripe || result.data.price !== Math.round(pkg.price * 100) || result.data.currency !== transformed.currency)) {
                      console.warn('Stripe metadata not applied for ' + pkg.slug + ', attempting to delete and recreate...');
                      if (existingEventTypeId) {
                        await deleteEventType(existingEventTypeId);
                        method = 'POST';
                        path = '/v2/event-types';
                        try {
                          const retryResult = await apiRequest(method, path, transformed);
                          console.log('Retry success for ' + pkg.slug + ':', JSON.stringify(retryResult, null, 2));
                        } catch (retryErr) {
                          console.error('Retry failed for ' + pkg.slug + ':', JSON.stringify(retryErr.data || retryErr.message, null, 2));
                        }
                      }
                    }
                  } catch (err) {
                    console.error('Failed for ' + pkg.slug + ':', JSON.stringify(err, null, 2));
                    console.error('Error details:', JSON.stringify(err.data || err.message, null, 2));
                  }
                  await new Promise(resolve => setTimeout(resolve, 2000)); // Increased to avoid rate limiting
                }
              } catch (e) {
                console.error('Error processing events:', JSON.stringify(e, null, 2));
                process.exit(1);
              }
            }
            processEvents().catch(console.error);
          EOF

name: Map and Deploy JSON to Cal.com

on:
  push:
    branches:
      - main
    paths:
      - 'packages.json'
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Verify packages.json
        run: |
          if [ ! -f packages.json ]; then
            echo "Error: packages.json not found"
            exit 1
          fi
          echo "packages.json verified"

      - name: Validate packages.json syntax
        run: |
          node -e "try { JSON.parse(require('fs').readFileSync('packages.json')); console.log('packages.json is valid JSON'); } catch (e) { console.error('Invalid JSON in packages.json:', e.message); process.exit(1); }"

      - name: Write utility functions
        run: |
          cat <<'SCRIPT' > utils.js
          const https = require('https');
          const fs = require('fs');

          function apiRequest(method, path, body = null, retries = 2) {
            return new Promise((resolve, reject) => {
              const options = {
                hostname: 'api.cal.com',
                path,
                method,
                headers: {
                  Authorization: `Bearer ${process.env.CALCOM_API_KEY || 'MISSING_API_KEY'}`,
                  'Content-Type': 'application/json'
                }
              };
              console.log(`[DEBUG] API request: ${method} ${path}`);
              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => {
                  console.log(`[DEBUG] Response status: ${res.statusCode}, headers: ${JSON.stringify(res.headers)}`);
                  console.log(`[DEBUG] Raw response: ${data}`);
                  if (res.statusCode >= 200 && res.statusCode < 300) {
                    try {
                      const parsed = JSON.parse(data || '{}');
                      resolve(parsed);
                    } catch (e) {
                      reject(new Error(`Failed to parse response for ${path}: ${e.message}`));
                    }
                  } else if ((res.statusCode === 429 || res.statusCode >= 500) && retries > 0) {
                    console.warn(`[WARN] Retrying ${method} ${path} (status ${res.statusCode}, ${retries} attempts left)`);
                    setTimeout(() => {
                      apiRequest(method, path, body, retries - 1).then(resolve).catch(reject);
                    }, 2000);
                  } else {
                    reject(new Error(`Request failed for ${path} with status ${res.statusCode}: ${data}`));
                  }
                });
              });
              req.on('error', (e) => reject(new Error(`Request error for ${path}: ${e.message}`)));
              if (body) {
                console.log(`[DEBUG] Request body: ${JSON.stringify(body)}`);
                req.write(JSON.stringify(body));
              }
              req.end();
            });
          }

          async function getAllEventTypes() {
            try {
              let eventTypes = [];
              let page = 1;
              while (true) {
                const res = await apiRequest('GET', `/api/v2/event-types?page=${page}&limit=100`);
                console.log(`[DEBUG] Event types response for page ${page}: ${JSON.stringify(res, null, 2)}`);
                const types = res.data?.eventTypeGroups?.flatMap(group => group.eventTypes || []) || [];
                if (!Array.isArray(types)) {
                  throw new Error(`Invalid event types response structure: ${JSON.stringify(res, null, 2)}`);
                }
                eventTypes = eventTypes.concat(types);
                if (!res.nextPage || types.length < 100) break;
                page++;
              }
              console.log(`[INFO] Retrieved ${eventTypes.length} event types`);
              return eventTypes;
            } catch (e) {
              console.error(`[ERROR] Error fetching event types: ${e.message}`);
              throw e;
            }
          }

          function deduplicatePackages(packages) {
            const seenSlugs = new Set();
            return packages.filter(pkg => {
              if (seenSlugs.has(pkg.slug)) {
                console.warn(`Duplicate slug detected: ${pkg.slug}. Skipping package: ${pkg.name}`);
                return false;
              }
              seenSlugs.add(pkg.slug);
              return true;
            });
          }

          function loadPackages() {
            try {
              const rawJson = fs.readFileSync('packages.json', 'utf8');
              let packages = JSON.parse(rawJson);
              if (packages.some(pkg => Object.keys(pkg).length === 1)) {
                packages = packages.map(p => Object.values(p)[0]);
              }
              return deduplicatePackages(packages);
            } catch (e) {
              console.error(`[ERROR] Failed to parse packages.json: ${e.message}`);
              console.error(`[DEBUG] JSON content near error: ${e.message.includes('position') ? rawJson.slice(Math.max(0, parseInt(e.message.match(/position (\d+)/)?.[1] || 0) - 50), parseInt(e.message.match(/position (\d+)/)?.[1] || 0) + 50) : 'N/A'}`);
              throw e;
            }
          }

          module.exports = { apiRequest, getAllEventTypes, deduplicatePackages, loadPackages };
          SCRIPT

      - name: Write event type insertion script
        run: |
          cat <<'SCRIPT' > insert-event-types.js
          const { apiRequest, getAllEventTypes, loadPackages } = require('./utils');

          const dayMap = {
            Monday: 'Monday', Tuesday: 'Tuesday', Wednesday: 'Wednesday',
            Thursday: 'Thursday', Friday: 'Friday', Saturday: 'Saturday', Sunday: 'Sunday',
            1: 'Monday', 2: 'Tuesday', 3: 'Wednesday', 4: 'Thursday', 5: 'Friday', 6: 'Saturday', 7: 'Sunday'
          };

          async function createSchedule(scheduleData) {
            try {
              const payload = {
                name: scheduleData.name,
                timeZone: scheduleData.timeZone,
                isDefault: scheduleData.isDefault ?? true,
                availability: scheduleData.availability.map(slot => ({
                  ...slot,
                  days: slot.days.map(day => dayMap[day] || day)
                }))
              };
              const result = await apiRequest('POST', '/api/v2/schedules', payload);
              return result.data.id;
            } catch (e) {
              console.error(`Failed to create schedule: ${e.message}`);
              return null;
            }
          }

          async function insertNewEventTypes() {
            try {
              const packages = loadPackages();
              if (!packages.length) throw new Error('No valid packages found');
              const existingEventTypes = await getAllEventTypes();
              const existingSlugs = new Set(existingEventTypes.map(e => e.slug));
              for (const pkg of packages) {
                if (!pkg.slug || !pkg.name) {
                  console.warn(`Invalid package: ${JSON.stringify(pkg)}`);
                  continue;
                }
                if (existingSlugs.has(pkg.slug)) {
                  console.log(`Event type ${pkg.slug} already exists, skipping`);
                  continue;
                }
                const priceText = pkg.discount > 0 
                  ? `**Price**: **$${pkg.price}** (Reg. ~~$${pkg.regPrice || pkg.regularPrice}~~) - ${pkg.discount}% OFF!`
                  : `**Price**: **$${pkg.price}**`;
                const servicesText = pkg.equipment && Array.isArray(pkg.equipment) && pkg.equipment.length > 0
                  ? `**Services Offered**:\n${pkg.equipment.map(e => `- ${e}`).join('\n')}`
                  : `**Services Included**: None`;
                const description = [
                  priceText,
                  `**Description**: ${pkg.description || 'No description provided'}`,
                  `**Guests**: ${pkg.guests || 'Not specified'}`,
                  `**Duration**: Up to ${pkg.maxDuration || 3} hours`,
                  servicesText,
                  `**Note**: ${pkg.note || 'No additional notes'}`
                ].join('\n\n');
                const hasPhoneNumberField = pkg.bookingFields?.some(field => field.name === 'phoneNumber');
                const hasEventLocationField = pkg.bookingFields?.some(field => field.name === 'eventLocation');
                const transformed = {
                  title: pkg.name,
                  slug: pkg.slug,
                  length: (pkg.maxDuration || 3) * 60,
                  description,
                  locations: pkg.locationTypes && Array.isArray(pkg.types) && pkg.types[0]?.location_type
                    ? [{

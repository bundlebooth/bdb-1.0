name: Map and Deploy JSON to Cal.com

on:
  push:
    branches:
      - main
    paths:
      - 'packages.json'
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Verify packages.json
        run: |
          if [ ! -f packages.json ]; then
            echo "Error: packages.json not found"
            exit 1
          fi
          echo "packages.json verified"

      - name: Validate packages.json syntax
        run: |
          node -e "try { JSON.parse(require('fs').readFileSync('packages.json')); console.log('packages.json is valid JSON'); } catch (e) { console.error('Invalid JSON in packages.json:', e.message); process.exit(1); }"

      - name: Write utility functions
        run: |
          cat <<'SCRIPT' > utils.js
          const https = require('https');
          const fs = require('fs');

          function apiRequest(method, path, body = null, retries = 2) {
            return new Promise((resolve, reject) => {
              const options = {
                hostname: 'api.cal.com',
                path,
                method,
                headers: {
                  Authorization: `Bearer ${process.env.CALCOM_API_KEY || 'MISSING_API_KEY'}`,
                  'Content-Type': 'application/json'
                }
              };
              console.log(`[DEBUG] API request: ${method} ${path}`);
              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => {
                  console.log(`[DEBUG] Response status: ${res.statusCode}, headers: ${JSON.stringify(res.headers)}`);
                  console.log(`[DEBUG] Raw response: ${data}`);
                  if (res.statusCode >= 200 && res.statusCode < 300) {
                    try {
                      const parsed = JSON.parse(data || '{}');
                      resolve(parsed);
                    } catch (e) {
                      reject(new Error(`Failed to parse response for ${path}: ${e.message}`));
                    }
                  } else if ((res.statusCode === 429 || res.statusCode >= 500) && retries > 0) {
                    console.warn(`[WARN] Retrying ${method} ${path} (status ${res.statusCode}, ${retries} attempts left)`);
                    setTimeout(() => {
                      apiRequest(method, path, body, retries - 1).then(resolve).catch(reject);
                    }, 2000);
                  } else {
                    if (res.statusCode === 404 && path.includes('/event-types')) {
                      resolve({ data: { eventTypeGroups: [] } });
                    } else {
                      reject(new Error(`Request failed for ${path} with status ${res.statusCode}: ${data}`));
                    }
                  }
                });
              });
              req.on('error', (e) => reject(new Error(`Request error for ${path}: ${e.message}`)));
              if (body) {
                console.log(`[DEBUG] Request body: ${JSON.stringify(body)}`);
                req.write(JSON.stringify(body));
              }
              req.end();
            });
          }

          async function getAllEventTypes() {
            try {
              let eventTypes = [];
              let page = 1;
              while (true) {
                const res = await apiRequest('GET', `/api/v2/event-types?page=${page}&limit=100&userId=1580301`);
                console.log(`[DEBUG] Event types response for page ${page}: ${JSON.stringify(res, null, 2)}`);
                const types = res.data?.eventTypeGroups?.flatMap(group => group.eventTypes || []) || [];
                if (!Array.isArray(types)) {
                  throw new Error(`Invalid event types response structure: ${JSON.stringify(res, null, 2)}`);
                }
                eventTypes = eventTypes.concat(types);
                if (!res.nextPage || types.length < 100) break;
                page++;
              }
              console.log(`[INFO] Retrieved ${eventTypes.length} event types`);
              console.log(`[DEBUG] Event types: ${JSON.stringify(eventTypes, null, 2)}`);
              return eventTypes;
            } catch (e) {
              console.error(`[ERROR] Error fetching event types: ${e.message}`);
              throw e;
            }
          }

          async function getCurrentUser() {
            try {
              const res = await apiRequest('GET', '/api/v2/me');
              console.log(`[DEBUG] Current user: ${JSON.stringify(res.data, null, 2)}`);
              return res.data;
            } catch (e) {
              console.error(`[ERROR] Error fetching current user: ${e.message}`);
              return null;
            }
          }

          function deduplicatePackages(packages) {
            const seenSlugs = new Set();
            return packages.filter(pkg => {
              if (seenSlugs.has(pkg.slug)) {
                console.warn(`Duplicate slug detected: ${pkg.slug}. Skipping package: ${pkg.name}`);
                return false;
              }
              seenSlugs.add(pkg.slug);
              return true;
            });
          }

          function loadPackages() {
            try {
              const rawJson = fs.readFileSync('packages.json', 'utf8');
              let packages = JSON.parse(rawJson);
              if (packages.some(pkg => Object.keys(pkg).length === 1)) {
                packages = packages.map(p => Object.values(p)[0]);
              }
              console.log(`[DEBUG] Loaded ${packages.length} packages from packages.json`);
              return deduplicatePackages(packages);
            } catch (e) {
              console.error(`[ERROR] Failed to parse packages.json: ${e.message}`);
              console.error(`[DEBUG] JSON content near error: ${e.message.includes('position') ? rawJson.slice(Math.max(0, parseInt(e.message.match(/position (\d+)/)?.[1] || 0) - 50), parseInt(e.message.match(/position (\d+)/)?.[1] || 0) + 50) : 'N/A'}`);
              throw e;
            }
          }

          module.exports = { apiRequest, getAllEventTypes, getCurrentUser, deduplicatePackages, loadPackages };
          SCRIPT

      - name: Write event type insertion script
        run: |
          cat <<'SCRIPT' > insert-event-types.js
          const { apiRequest, getAllEventTypes, getCurrentUser, loadPackages } = require('./utils');

          const dayMap = {
            Monday: 'MONDAY', Tuesday: 'TUESDAY', Wednesday: 'WEDNESDAY',
            Thursday: 'THURSDAY', Friday: 'FRIDAY', Saturday: 'SATURDAY', Sunday: 'SUNDAY',
            1: 'MONDAY', 2: 'TUESDAY', 3: 'WEDNESDAY', 4: 'THURSDAY', 5: 'FRIDAY', 6: 'SATURDAY', 7: 'SUNDAY'
          };

          async function createSchedule(pkg) {
            try {
              const payload = {
                name: `${pkg.name} Schedule`,
                timeZone: pkg.timeZone || 'America/Toronto',
                isDefault: true,
                availability: [{
                  days: (pkg.availabilityDays || ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']).map(day => dayMap[day] || day),
                  startTime: pkg.startTime || '09:00:00',
                  endTime: pkg.endTime || '23:59:00'
                }]
              };
              console.log(`[DEBUG] Creating schedule for ${pkg.slug}: ${JSON.stringify(payload)}`);
              const result = await apiRequest('POST', '/api/v2/schedules', payload);
              console.log(`[INFO] Created schedule ID: ${result.data.id} for ${pkg.slug}`);
              return result.data.id;
            } catch (e) {
              console.error(`[ERROR] Failed to create schedule for ${pkg.slug}: ${e.message}`);
              return null;
            }
          }

          async function getEventTypeId(slug) {
            try {
              const res = await apiRequest('GET', `/api/v2/event-types?slug=${encodeURIComponent(slug)}&userId=1580301`);
              const eventTypes = res.data?.eventTypeGroups?.flatMap(group => group.eventTypes || []) || [];
              console.log(`[DEBUG] Fetched event type for slug ${slug}: ${JSON.stringify(eventTypes[0])}`);
              return eventTypes.length ? eventTypes[0].id : null;
            } catch (e) {
              console.error(`[ERROR] Error fetching event type ID for ${slug}: ${e.message}`);
              return null;
            }
          }

          async function inspectEventType(slug) {
            try {
              const res = await apiRequest('GET', `/api/v2/event-types?slug=${encodeURIComponent(slug)}&userId=1580301`);
              const eventTypes = res.data?.eventTypeGroups?.flatMap(group => group.eventTypes || []) || [];
              console.log(`[DEBUG] Inspected event type ${slug}: ${JSON.stringify(eventTypes[0], null, 2)}`);
              return eventTypes[0] || null;
            } catch (e) {
              console.error(`[ERROR] Error inspecting event type ${slug}: ${e.message}`);
              return null;
            }
          }

          async function insertNewEventTypes() {
            try {
              const user = await getCurrentUser();
              if (!user) throw new Error('Failed to fetch current user');
              console.log(`[INFO] Authenticated as user ID: ${user.id}, slug: ${user.profile?.slug}`);
              const packages = loadPackages();
              if (!packages.length) throw new Error('No valid packages found');
              console.log(`[INFO] Processing ${packages.length} packages`);
              const existingEventTypes = await getAllEventTypes();
              const existingSlugs = new Set(existingEventTypes.map(e => e.slug));
              for (const pkg of packages) {
                if (!pkg.slug || !pkg.name) {
                  console.warn(`[WARN] Invalid package: ${JSON.stringify(pkg)}`);
                  continue;
                }
                console.log(`[INFO] Processing package: ${pkg.slug}`);
                console.log(`[DEBUG] Package details: ${JSON.stringify(pkg, null, 2)}`);
                const priceText = pkg.discount > 0 
                  ? `**Price**: **$${pkg.price}** (Reg. ~~$${pkg.regPrice || pkg.regularPrice}~~) - ${pkg.discount}% OFF!`
                  : `**Price**: **$${pkg.price}**`;
                const servicesText = pkg.equipment && Array.isArray(pkg.equipment) && pkg.equipment.length > 0
                  ? `**Services Offered**:\n${pkg.equipment.map(e => `- ${e}`).join('\n')}`
                  : `**Services Included**: None`;
                const description = [
                  priceText,
                  `**Description**: ${pkg.description || 'No description provided'}`,
                  `**Guests**: ${pkg.guests || 'Not specified'}`,
                  `**Duration**: Up to ${pkg.maxDuration || 3} hours`,
                  servicesText,
                  `**Note**: ${pkg.note || 'No additional notes'}`
                ].join('\n\n');
                const transformed = {
                  title: pkg.name,
                  slug: pkg.slug,
                  length: (pkg.maxDuration || 3) * 60,
                  description,
                  bookingFields: pkg.bookingFields.map(field => ({
                    type: field.type,
                    label: field.label,
                    required: field.required,
                    placeholder: field.placeholder
                  })),
                  locations: pkg.locations?.length ? pkg.locations.map(loc => ({
                    type: loc.location_type || 'address',
                    address: loc.location || 'To be provided by client'
                  })) : [{ type: 'address', address: 'To be provided by client' }],
                  minimumBookingNotice: pkg.minimumBookingNotice || 20160,
                  disableGuests: pkg.disableGuests || true,
                  scheduleId: null
                };
                let scheduleId = await createSchedule(pkg);
                if (!scheduleId) {
                  console.warn(`[WARN] Skipping event type ${pkg.slug} due to schedule creation failure`);
                  continue;
                }
                transformed.scheduleId = scheduleId;
                if (existingSlugs.has(pkg.slug)) {
                  console.log(`[INFO] Event type ${pkg.slug} already exists, inspecting and updating`);
                  await inspectEventType(pkg.slug);
                  const eventTypeId = await getEventTypeId(pkg.slug);
                  if (!eventTypeId) {
                    console.warn(`[WARN] Could not find ID for event type ${pkg.slug}, skipping update`);
                    continue;
                  }
                  try {
                    console.log(`[DEBUG] Updating event type ${pkg.slug} with payload: ${JSON.stringify(transformed)}`);
                    await apiRequest('PATCH', `/api/v2/event-types/${eventTypeId}`, transformed);
                    console.log(`[INFO] Updated event type: ${pkg.slug}`);
                    await inspectEventType(pkg.slug);
                  } catch (e) {
                    console.error(`[ERROR] Failed to update event type ${pkg.slug}: ${e.message}`);
                    try {
                      const errorData = JSON.parse(e.message.split(': ')[1] || '{}');
                      console.error(`[DEBUG] API error details: ${JSON.stringify(errorData, null, 2)}`);
                    } catch (parseError) {
                      console.error(`[DEBUG] Failed to parse API error: ${parseError.message}`);
                    }
                    continue;
                  }
                } else {
                  try {
                    console.log(`[DEBUG] Creating event type ${pkg.slug} with payload: ${JSON.stringify(transformed)}`);
                    const result = await apiRequest('POST', '/api/v2/event-types', transformed);
                    console.log(`[INFO] Created event type: ${pkg.slug} with ID: ${result.data.id}`);
                    await inspectEventType(pkg.slug);
                  } catch (e) {
                    console.error(`[ERROR] Failed to create event type ${pkg.slug}: ${e.message}`);
                    try {
                      const errorData = JSON.parse(e.message.split(': ')[1] || '{}');
                      console.error(`[DEBUG] API error details: ${JSON.stringify(errorData, null, 2)}`);
                    } catch (parseError) {
                      console.error(`[DEBUG] Failed to parse API error: ${parseError.message}`);
                    }
                    if (e.message.includes('already has an event type with this slug')) {
                      console.log(`[INFO] Duplicate slug detected for ${pkg.slug}, attempting update`);
                      const eventTypeId = await getEventTypeId(pkg.slug);
                      if (eventTypeId) {
                        try {
                          await apiRequest('PATCH', `/api/v2/event-types/${eventTypeId}`, transformed);
                          console.log(`[INFO] Updated event type: ${pkg.slug}`);
                          await inspectEventType(pkg.slug);
                        } catch (updateError) {
                          console.error(`[ERROR] Failed to update event type ${pkg.slug} after duplicate: ${updateError.message}`);
                        }
                      }
                      continue;
                    }
                    throw e;
                  }
                }
                await new Promise(resolve => setTimeout(resolve, 5000));
              }
              console.log('[INFO] Event type insertion completed');
            } catch (e) {
              console.error(`[FATAL] Fatal error during insertion: ${e.message}`);
              console.error(`[FATAL] Stack trace: ${e.stack}`);
              process.exit(1);
            }
          }

          insertNewEventTypes();
          SCRIPT

      - name: Insert new event types
        env:
          CALCOM_API_KEY: ${{ secrets.CALCOM_API_KEY }}
        run: |
          node insert-event-types.js > insert-log.txt 2>&1 || {
            echo "Insertion script failed. Check logs for details."
            cat insert-log.txt
            exit 1
          }

      - name: Write payment configuration script
        run: |
          cat <<'SCRIPT' > configure-payments.js
          const { apiRequest, loadPackages } = require('./utils');

          async function getEventTypeId(slug) {
            try {
              const res = await apiRequest('GET', `/api/v2/event-types?slug=${encodeURIComponent(slug)}&userId=1580301`);
              const eventTypes = res.data?.eventTypeGroups?.flatMap(group => group.eventTypes || []) || [];
              return eventTypes.length ? eventTypes[0].id : null;
            } catch (e) {
              console.error(`Error fetching event type ID for ${slug}: ${e.message}`);
              return null;
            }
          }

          async function configurePayments() {
            try {
              const packages = loadPackages();
              for (const pkg of packages) {
                if (!pkg.slug || !pkg.name) {
                  console.warn(`Invalid package: ${JSON.stringify(pkg)}`);
                  continue;
                }
                if (!pkg.price || pkg.price <= 0) {
                  console.log(`Skipping payment for ${pkg.slug}: invalid price`);
                  continue;
                }
                const eventTypeId = await getEventTypeId(pkg.slug);
                if (!eventTypeId) {
                  console.warn(`No event type found for ${pkg.slug}`);
                  continue;
                }
                const paymentPayload = {
                  price: Math.round(pkg.price * 100),
                  currency: pkg.currency?.toLowerCase() || 'cad',
                  metadata: {
                    apps: {
                      stripe: {
                        enabled: true,
                        price: Math.round(pkg.price * 100),
                        currency: pkg.currency?.toLowerCase() || 'cad'
                      }
                    }
                  }
                };
                await apiRequest('PATCH', `/api/v2/event-types/${eventTypeId}`, paymentPayload);
                console.log(`Configured payment for: ${pkg.slug}`);
                await new Promise(resolve => setTimeout(resolve, 2000));
              }
              console.log('Payment configuration completed');
            } catch (e) {
              console.error(`Fatal error during payment configuration: ${e.message}`);
              process.exit(1);
            }
          }

          configurePayments();
          SCRIPT

      - name: Configure payments for event types
        env:
          CALCOM_API_KEY: ${{ secrets.CALCOM_API_KEY }}
        run: |
          node configure-payments.js > payment-log.txt 2>&1 || {
            echo "Payment configuration failed. Check logs for details."
            cat payment-log.txt
            exit 1
          }

      - name: Archive logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deploy-logs
          path: |
            *.log
            *.txt
          retention-days: 7

name: Map and Deploy JSON to Cal.com

on:
  push:
    branches:
      - main
    paths:
      - 'packages.json'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Verify packages.json
        run: |
          if [ ! -f packages.json ]; then
            echo "Error: packages.json not found"
            exit 1
          fi

      - name: Write event type script
        run: |
          cat <<'SCRIPT' > deploy.js
          const fs = require('fs');
          const https = require('https');
          const dayMap = {
            'Monday': 'Monday', 'Tuesday': 'Tuesday', 'Wednesday': 'Wednesday', 'Thursday': 'Thursday',
            'Friday': 'Friday', 'Saturday': 'Saturday', 'Sunday': 'Sunday',
            1: 'Monday', 2: 'Tuesday', 3: 'Wednesday', 4: 'Thursday', 5: 'Friday', 6: 'Saturday', 7: 'Sunday'
          };
          function apiRequest(method, path, body = null) {
            return new Promise((resolve, reject) => {
              const options = {
                hostname: 'api.cal.com',
                path: path,
                method: method,
                headers: {
                  'Authorization': 'Bearer ' + process.env.CALCOM_API_KEY,
                  'Content-Type': 'application/json',
                  'cal-api-version': '2024-06-14'
                }
              };
              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => { data += chunk; });
                res.on('end', () => {
                  if (res.statusCode >= 200 && res.statusCode < 300) {
                    try {
                      resolve(JSON.parse(data));
                    } catch (e) {
                      resolve({});
                    }
                  } else {
                    reject({ statusCode: res.statusCode, data: data });
                  }
                });
              });
              req.on('error', (e) => { reject(e); });
              if (body) req.write(JSON.stringify(body));
              req.end();
            });
          }
          async function getEventType(id) {
            try {
              console.log('Fetching event type with ID: ' + id);
              const res = await apiRequest('GET', '/v2/event-types/' + id);
              return res.data;
            } catch (e) {
              console.error('Error fetching event type ID ' + id + ': ' + JSON.stringify(e));
              return null;
            }
          }
          async function deleteEventType(id) {
            try {
              console.log('Deleting event type with ID: ' + id);
              await apiRequest('DELETE', '/v2/event-types/' + id);
              console.log('Deleted event type with ID: ' + id);
            } catch (e) {
              console.error('Error deleting event type with ID ' + id + ': ' + JSON.stringify(e));
            }
          }
          async function createSchedule(scheduleData) {
            try {
              console.log('Creating schedule:', scheduleData.name);
              const mappedAvailability = scheduleData.availability.map(slot => ({
                ...slot,
                days: slot.days.map(day => dayMap[day] || day)
              }));
              const payload = {
                name: scheduleData.name,
                timeZone: scheduleData.timeZone,
                isDefault: scheduleData.isDefault !== undefined ? scheduleData.isDefault : true,
                availability: mappedAvailability
              };
              console.log('Schedule payload:', JSON.stringify(payload));
              const result = await apiRequest('POST', '/v2/schedules', payload);
              return result.data.id;
            } catch (e) {
              console.error('Error creating schedule:', JSON.stringify(e));
              return null;
            }
          }
          async function verifyEventType(slug, expected, eventTypeId) {
            try {
              const eventType = await getEventType(eventTypeId);
              if (!eventType || eventType.slug !== slug) {
                console.error('Cannot verify: Event type not found for slug: ' + slug + ' and ID: ' + eventTypeId);
                process.exit(1);
              }
              console.log('Verifying event type: ' + slug);
              const errors = [];
              if (eventType.disableGuests !== expected.disableGuests) {
                errors.push(`disableGuests: ${eventType.disableGuests} (Expected: ${expected.disableGuests})`);
              }
              if (eventType.disableGuestsCancelling !== expected.disableGuestsCancelling) {
                errors.push(`disableGuestsCancelling: ${eventType.disableGuestsCancelling || false} (Expected: ${expected.disableGuestsCancelling})`);
              }
              if (eventType.disableGuestsRescheduling !== expected.disableGuestsRescheduling) {
                errors.push(`disableGuestsRescheduling: ${eventType.disableGuestsRescheduling || false} (Expected: ${expected.disableGuestsRescheduling})`);
              }
              if (eventType.metadata?.disableCalVideoTranscription !== expected.metadata.disableCalVideoTranscription) {
                errors.push(`disableCalVideoTranscription: ${eventType.metadata?.disableCalVideoTranscription || false} (Expected: ${expected.metadata.disableCalVideoTranscription})`);
              }
              if (JSON.stringify(eventType.locations) !== JSON.stringify(expected.locations)) {
                errors.push(`locations: ${JSON.stringify(eventType.locations)} (Expected: ${JSON.stringify(expected.locations)})`);
              }
              if (expected.bookingFields && JSON.stringify(eventType.bookingFields) !== JSON.stringify(expected.bookingFields)) {
                errors.push(`bookingFields: ${JSON.stringify(eventType.bookingFields)} (Expected: ${JSON.stringify(expected.bookingFields)})`);
              }
              if (errors.length > 0) {
                console.error('Verification failed for ' + slug + ':');
                errors.forEach(err => console.error(err));
                process.exit(1);
              } else {
                console.log('Verification successful for ' + slug);
              }
            } catch (e) {
              console.error('Error verifying event type ' + slug + ': ' + JSON.stringify(e));
              process.exit(1);
            }
          }
          async function processEvents() {
            try {
              console.log('Reading packages.json...');
              let packages = JSON.parse(fs.readFileSync('packages.json'));
              if (packages.some(pkg => Object.keys(pkg).length === 1)) {
                packages = packages.map(pkg => Object.values(pkg)[0]);
              }
              for (let i = 0; i < packages.length; i++) {
                const pkg = packages[i];
                if (!pkg.slug || !pkg.name) {
                  console.error('Invalid package: missing slug or name: ' + JSON.stringify(pkg));
                  process.exit(1);
                }
                console.log('Processing package: ' + pkg.slug);
                if (!pkg.hasOwnProperty('disableGuestsCancelling')) {
                  console.warn('Warning: disableGuestsCancelling not set for ' + pkg.slug + ', defaulting to false');
                } else if (pkg.disableGuestsCancelling !== true) {
                  console.warn('Warning: disableGuestsCancelling is ' + pkg.disableGuestsCancelling + ' for ' + pkg.slug);
                }
                if (!pkg.hasOwnProperty('disableGuestsRescheduling')) {
                  console.warn('Warning: disableGuestsRescheduling not set for ' + pkg.slug + ', defaulting to false');
                } else if (pkg.disableGuestsRescheduling !== true) {
                  console.warn('Warning: disableGuestsRescheduling is ' + pkg.disableGuestsRescheduling + ' for ' + pkg.slug);
                }
                if (!pkg.hasOwnProperty('disableCalVideoTranscription')) {
                  console.warn('Warning: disableCalVideoTranscription not set for ' + pkg.slug + ', defaulting to false');
                } else if (pkg.disableCalVideoTranscription !== true) {
                  console.warn('Warning: disableCalVideoTranscription is ' + pkg.disableCalVideoTranscription + ' for ' + pkg.slug);
                }
                if (!pkg.hasOwnProperty('disableGuests')) {
                  console.warn('Warning: disableGuests not set for ' + pkg.slug + ', defaulting to false');
                } else if (pkg.disableGuests !== true) {
                  console.warn('Warning: disableGuests is ' + pkg.disableGuests + ' for ' + pkg.slug);
                }
                const priceText = pkg.discount > 0 
                  ? `**Price**: **$${pkg.price}** (Reg. ~~$${pkg.regularPrice}~~) - ${pkg.discount}% OFF!`
                  : `**Price**: **$${pkg.price}**`;
                const servicesText = pkg.servicesIncluded && Array.isArray(pkg.servicesIncluded)
                  ? `**Services Included**:\n${pkg.servicesIncluded.map(s => `- ${s}`).join('\n')}`
                  : `**Services Included**: None`;
                const description = [
                  priceText,
                  `**Description**: ${pkg.description || 'No description provided'}`,
                  `**Guests**: ${pkg.guests || 'Not specified'}`,
                  `**Duration**: Up to ${pkg.maxDuration || 3} hours`,
                  servicesText,
                  `**Note**: ${pkg.note || 'No additional notes'}`
                ].join('\n\n');
                const transformed = {
                  title: pkg.name || 'Placeholder Title',
                  slug: pkg.slug || 'placeholder',
                  lengthInMinutes: pkg.maxDuration ? pkg.maxDuration * 60 : 180,
                  description: description,
                  locations: pkg.locations && Array.isArray(pkg.locations) && pkg.locations[0]?.location_type === 'ask'
                    ? [{ type: 'address', address: 'To be provided by client', public: true }]
                    : pkg.location === 'Online'
                      ? [{ type: 'integration', integration: 'cal-video' }]
                      : [{ type: 'address', address: pkg.location || 'Toronto, ON', public: true }],
                  availability: pkg.availability || {
                    days: pkg.availabilityDays
                      ? pkg.availabilityDays.map(day => dayMap[day] || day)
                      : ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'],
                    startTime: pkg.startTime || '09:00',
                    endTime: pkg.endTime || '23:59'
                  },
                  tags: [],
                  disableGuests: pkg.disableGuests || false,
                  disableGuestsCancelling: pkg.disableGuestsCancelling || false,
                  disableGuestsRescheduling: pkg.disableGuestsRescheduling || false,
                  bookingFields: pkg.bookingFields || [],
                  color: pkg.color || undefined,
                  minimumBookingNotice: pkg.minimumBookingNotice || undefined,
                  bookerLayouts: pkg.bookerLayouts || undefined,
                  metadata: {
                    disableCalVideoTranscription: pkg.disableCalVideoTranscription || false
                  }
                };
                if (Array.isArray(pkg.eventType)) {
                  transformed.tags = transformed.tags.concat(pkg.eventType);
                }
                if (pkg.packageType) transformed.tags.push(pkg.packageType);
                if (pkg.Sale === 'Y') transformed.tags.push('On Sale');
                if (pkg.New === 'Y') transformed.tags.push('New');
                if (pkg.availability && Array.isArray(pkg.availability.schedules)) {
                  const scheduleIds = [];
                  for (const schedule of pkg.availability.schedules) {
                    const scheduleId = await createSchedule(schedule);
                    if (scheduleId) {
                      scheduleIds.push(scheduleId);
                    } else {
                      console.error('Failed to create schedule for ' + pkg.slug);
                      process.exit(1);
                    }
                  }
                  if (scheduleIds.length > 0) {
                    transformed.scheduleIds = scheduleIds;
                  }
                }
                console.log('Request payload for ' + pkg.slug + ': ' + JSON.stringify(transformed));
                const existingEventTypeId = await getEventType(transformed.slug)?.id;
                if (existingEventTypeId) {
                  await deleteEventType(existingEventTypeId);
                }
                try {
                  const result = await apiRequest('POST', '/v2/event-types', transformed);
                  console.log('API response for ' + pkg.slug + ': ' + JSON.stringify(result, null, 2));
                  await verifyEventType(pkg.slug, transformed, result.data.id);
                } catch (err) {
                  console.error('Failed for ' + pkg.slug + ': ' + JSON.stringify(err));
                  console.error('Error details: ' + JSON.stringify(err.data || err.message));
                  process.exit(1);
                }
                await new Promise(resolve => setTimeout(resolve, 5000));
              }
            } catch (e) {
              console.error('Error processing events:');
              console.error('Message:', e.message);
              console.error('Stack:', e.stack);
              console.error('Full Error:', JSON.stringify(e, Object.getOwnPropertyNames(e)));
              process.exit(1);
            }
          }
          processEvents().catch(e => {
            console.error('Uncaught error in processEvents:');
            console.error('Message:', e.message);
            console.error('Stack:', e.stack);
            console.error('Full Error:', JSON.stringify(e, Object.getOwnPropertyNames(e)));
            process.exit(1);
          });
          SCRIPT
          cat deploy.js

      - name: Create event types
        env:
          CALCOM_API_KEY: ${{ secrets.CALCOM_API_KEY }}
        run: node deploy.js

      - name: Write payment configuration script
        run: |
          cat <<'SCRIPT' > configure-payments.js
          const fs = require('fs');
          const https = require('https');
          function apiRequest(method, path, body = null) {
            return new Promise((resolve, reject) => {
              const options = {
                hostname: 'api.cal.com',
                path: path,
                method: method,
                headers: {
                  'Authorization': 'Bearer ' + process.env.CALCOM_API_KEY,
                  'Content-Type': 'application/json',
                  'cal-api-version': '2024-06-14'
                }
              };
              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => { data += chunk; });
                res.on('end', () => {
                  if (res.statusCode >= 200 && res.statusCode < 300) {
                    try {
                      resolve(JSON.parse(data));
                    } catch (e) {
                      resolve({});
                    }
                  } else {
                    reject({ statusCode: res.statusCode, data: data });
                  }
                });
              });
              req.on('error', (e) => { reject(e); });
              if (body) req.write(JSON.stringify(body));
              req.end();
            });
          }
          async function getEventTypeId(slug) {
            try {
              console.log('Fetching event type ID for slug: ' + slug);
              const res = await apiRequest('GET', '/v2/event-types');
              const eventTypes = res.event_types || [];
              for (let i = 0; i < eventTypes.length; i++) {
                if (eventTypes[i].slug === slug) {
                  return eventTypes[i].id;
                }
              }
              return null;
            } catch (e) {
              console.error('Error fetching event types: ' + JSON.stringify(e));
              return null;
            }
          }
          async function configurePayments() {
            try {
              console.log('Reading packages.json for payment configuration...');
              let packages = JSON.parse(fs.readFileSync('packages.json'));
              if (packages.some(pkg => Object.keys(pkg).length === 1)) {
                packages = packages.map(pkg => Object.values(pkg)[0]);
              }
              for (let i = 0; i < packages.length; i++) {
                const pkg = packages[i];
                if (!pkg.slug || !pkg.name) {
                  console.error('Invalid package: missing slug or name: ' + JSON.stringify(pkg));
                  process.exit(1);
                }
                if (!pkg.price || pkg.price <= 0) {
                  console.log('No payment configuration needed for ' + pkg.slug);
                  continue;
                }
                console.log('Configuring payments for ' + pkg.slug);
                const eventTypeId = await getEventTypeId(pkg.slug);
                if (!eventTypeId) {
                  console.error('Event type not found for slug: ' + pkg.slug);
                  continue;
                }
                const paymentPayload = {
                  price: Math.round(pkg.price * 100),
                  currency: pkg.currency?.toLowerCase() || 'cad',
                  metadata: {
                    apps: {
                      stripe: {
                        enabled: true,
                        price: Math.round(pkg.price * 100),
                        currency: pkg.currency?.toLowerCase() || 'cad'
                      }
                    }
                  }
                };
                console.log('Payment payload for ' + pkg.slug + ': ' + JSON.stringify(paymentPayload));
                try {
                  const result = await apiRequest('PATCH', '/v2/event-types/' + eventTypeId, paymentPayload);
                  console.log('Payment configuration success for ' + pkg.slug + ': ' + JSON.stringify(result));
                  if (!result.data.metadata?.apps?.stripe || result.data.price !== paymentPayload.price || result.data.currency !== paymentPayload.currency) {
                    console.error('Stripe metadata not applied for ' + pkg.slug + '. Check Stripe configuration and API permissions.');
                  }
                } catch (err) {
                  console.error('Payment configuration failed for ' + pkg.slug + ': ' + JSON.stringify(err));
                  console.error('Error details: ' + JSON.stringify(err.data || err.message));
                  process.exit(1);
                }
                await new Promise(resolve => setTimeout(resolve, 2000));
              }
            } catch (e) {
              console.error('Error configuring payments:');
              console.error('Message:', e.message);
              console.error('Stack:', e.stack);
              console.error('Full Error:', JSON.stringify(e, Object.getOwnPropertyNames(e)));
              process.exit(1);
            }
          }
          configurePayments().catch(e => {
            console.error('Uncaught error in configurePayments:');
            console.error('Message:', e.message);
            console.error('Stack:', e.stack);
            console.error('Full Error:', JSON.stringify(e, Object.getOwnPropertyNames(e)));
            process.exit(1);
          });
          SCRIPT
          cat configure-payments.js

      - name: Configure payments
        env:
          CALCOM_API_KEY: ${{ secrets.CALCOM_API_KEY }}
        run: node configure-payments.js

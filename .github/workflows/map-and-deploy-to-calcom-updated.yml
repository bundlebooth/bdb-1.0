name: Map and Deploy JSON to Cal.com (Fully Automated Stripe Enabled)

on:
  push:
    branches:
      - main
    paths:
      - 'packages.json'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Map JSON and Push to Cal.com
        env:
          CALCOM_API_KEY: ${{ secrets.CALCOM_API_KEY }}
        run: |
          node <<EOF
            const fs = require('fs');
            const https = require('https');

            const dayMap = {
              'Monday': 1, 'Tuesday': 2, 'Wednesday': 3, 'Thursday': 4,
              'Friday': 5, 'Saturday': 6, 'Sunday': 7
            };

            function apiRequest(method, path, body = null) {
              return new Promise((resolve, reject) => {
                const options = {
                  hostname: 'api.cal.com',
                  path,
                  method,
                  headers: {
                    'Authorization': 'Bearer ' + process.env.CALCOM_API_KEY,
                    'Content-Type': 'application/json'
                  }
                };
                const req = https.request(options, (res) => {
                  let data = '';
                  res.on('data', (chunk) => data += chunk);
                  res.on('end', () => {
                    if (res.statusCode >= 200 && res.statusCode < 300) {
                      resolve(JSON.parse(data));
                    } else {
                      reject(\`API Error \${res.statusCode}: \${data}\`);
                    }
                  });
                });
                req.on('error', (e) => reject(e));
                if (body) req.write(JSON.stringify(body));
                req.end();
              });
            }

            async function getPaymentProviderId() {
              try {
                const providers = await apiRequest('GET', '/v2/payment-providers');
                const stripe = providers.find(p => p.type === 'stripe');
                if (!stripe) throw new Error('Stripe provider not found');
                console.log('Using paymentProviderId:', stripe.id);
                return stripe.id;
              } catch (e) {
                console.error('Error fetching payment providers:', e);
                process.exit(1);
              }
            }

            async function getEventTypeId(slug) {
              try {
                const res = await apiRequest('GET', '/v2/event-types');
                const event = res.event_types.find(e => e.slug === slug);
                return event ? event.id : null;
              } catch (e) {
                console.error('Error fetching event types:', e);
                return null;
              }
            }

            async function processEvents() {
              try {
                const paymentProviderId = await getPaymentProviderId();

                console.log('Reading packages.json...');
                let packages = JSON.parse(fs.readFileSync('packages.json'));

                if (packages.some(pkg => Object.keys(pkg).length === 1)) {
                  packages = packages.map(pkg => Object.values(pkg)[0]);
                }

                for (const pkg of packages) {
                  if (!pkg.slug || !pkg.name) {
                    console.error('Invalid package: missing slug or name', pkg);
                    process.exit(1);
                  }
                }

                for (const pkg of packages) {
                  console.log('Processing package:', pkg.slug);

                  const transformed = {
                    title: pkg.name || 'Placeholder Title',
                    slug: pkg.slug || 'placeholder',
                    length: pkg.maxDuration ? pkg.maxDuration * 60 : 180,
                    description: pkg.description || 'No description provided',
                    locations: [{ type: 'inPerson', address: pkg.location || 'Toronto, ON' }],
                    availability: {
                      days: pkg.availabilityDays
                        ? pkg.availabilityDays.map(day => dayMap[day] || 1)
                        : [1, 2, 3, 4, 5],
                      startTime: pkg.startTime || '09:00',
                      endTime: pkg.endTime || '17:00'
                    },
                    tags: [
                      ...(pkg.eventType || []),
                      pkg.packageType,
                      pkg.Sale === 'Y' ? 'On Sale' : '',
                      pkg.New === 'Y' ? 'New' : ''
                    ].filter(Boolean)
                  };

                  if (pkg.price > 0) {
                    transformed.requiresPayment = true;
                    transformed.payments = {
                      enabled: true,
                      price: pkg.price * 100,  // cents
                      paymentProvider: 'stripe',
                      paymentProviderId: paymentProviderId,
                      currency: 'CAD'
                    };
                  }

                  const eventTypeId = await getEventTypeId(transformed.slug);
                  const method = eventTypeId ? 'PUT' : 'POST';
                  const path = eventTypeId ? \`/v2/event-types/\${eventTypeId}\` : '/v2/event-types';

                  try {
                    const result = await apiRequest(method, path, transformed);
                    console.log(\`Success for \${transformed.slug}: \`, result);
                  } catch (err) {
                    console.error(\`Failed for \${transformed.slug}: \`, err);
                  }

                  await new Promise(resolve => setTimeout(resolve, 500)); // slight delay for rate limiting
                }
              } catch (e) {
                console.error('Error processing events:', e);
                process.exit(1);
              }
            }

            processEvents().catch(console.error);
          EOF

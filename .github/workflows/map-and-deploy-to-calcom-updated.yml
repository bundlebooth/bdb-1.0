name: Map and Deploy JSON to Cal.com

on:
  push:
    branches:
      - main
    paths:
      - 'packages.json'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Validate Stripe Configuration
        env:
          STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
          CALCOM_API_KEY: ${{ secrets.CALCOM_API_KEY }}
        run: |
          if [ -z "$STRIPE_SECRET_KEY" ]; then
            echo "Error: STRIPE_SECRET_KEY is not set in GitHub Secrets."
            exit 1
          fi
          if [ -z "$CALCOM_API_KEY" ]; then
            echo "Error: CALCOM_API_KEY is not set in GitHub Secrets."
            exit 1
          fi
          echo "Stripe configuration validated successfully."

      - name: Map JSON and Push to Cal.com
        env:
          CALCOM_API_KEY: ${{ secrets.CALCOM_API_KEY }}
          STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
        run: |
          node <<EOF
            const fs = require('fs');
            const https = require('https');
            const dayMap = {
              'Monday': 1, 'Tuesday': 2, 'Wednesday': 3, 'Thursday': 4,
              'Friday': 5, 'Saturday': 6, 'Sunday': 7
            };

            async function getEventTypeId(slug) {
              let page = 1;
              let eventTypeId = null;

              while (page) {
                const options = {
                  hostname: 'api.cal.com',
                  path: \`/v2/event-types?page=\${page}\`,
                  method: 'GET',
                  headers: { Authorization: 'Bearer ' + process.env.CALCOM_API_KEY }
                };

                const response = await new Promise((resolve, reject) => {
                  const req = https.request(options, (res) => {
                    let data = '';
                    res.on('data', (chunk) => data += chunk);
                    res.on('end', () => resolve({ status: res.statusCode, data }));
                  });
                  req.on('error', (e) => reject(e));
                  req.end();
                });

                if (response.status !== 200) {
                  console.error(\`Error fetching event types (page \${page}): Status \${response.status}, Response: \${response.data}\`);
                  return null;
                }

                try {
                  const result = JSON.parse(response.data);
                  const eventTypes = result.event_types || [];
                  const event = eventTypes.find(e => e.slug === slug);
                  if (event) {
                    eventTypeId = event.id;
                    break;
                  }
                  // Check for next page (assuming API uses 'next_page' or similar)
                  page = result.next_page || null;
                } catch (e) {
                  console.error(\`Error parsing event types (page \${page}): \${e.message}\`);
                  return null;
                }

                // Avoid rate limiting
                if (page) await new Promise(resolve => setTimeout(resolve, 500));
              }

              return eventTypeId;
            }

            async function processEvents() {
              try {
                console.log('Reading packages.json...');
                let packages = JSON.parse(fs.readFileSync('packages.json'));
                // Ensure packages is an array
                if (!Array.isArray(packages)) {
                  packages = [packages];
                }
                // Handle nested package structure if present
                if (packages.some(pkg => Object.keys(pkg).length === 1)) {
                  packages = packages.map(pkg => Object.values(pkg)[0]);
                }
                // Validate packages.json
                for (const pkg of packages) {
                  if (!pkg.slug || !pkg.name) {
                    console.error('Invalid package: missing slug or name', pkg);
                    process.exit(1);
                  }
                  if (pkg.price > 0 && !process.env.STRIPE_SECRET_KEY) {
                    console.error('Error: STRIPE_SECRET_KEY missing for package with price:', pkg.slug);
                    process.exit(1);
                  }
                }

                console.log('Processing packages with Stripe payments enabled...');
                for (const pkg of packages) {
                  console.log('Processing package:', pkg.slug);
                  // Build enhanced description with additional fields
                  const description = [
                    pkg.description || 'No description provided',
                    pkg.equipment && Array.isArray(pkg.equipment) ? \`Equipment: \${pkg.equipment.join(', ')}\` : '',
                    pkg.note ? \`Note: \${pkg.note}\` : '',
                    pkg.guests ? \`Guests: \${pkg.guests}\` : '',
                    pkg.regPrice ? \`Regular Price: \$\${pkg.regPrice}\` : '',
                    pkg.discount ? \`Discount: \${pkg.discount}%\` : ''
                  ].filter(Boolean).join('\n');

                  const transformed = {
                    title: pkg.name || 'Placeholder Title',
                    slug: pkg.slug || 'placeholder',
                    length: pkg.maxDuration ? pkg.maxDuration * 60 : 360, // Convert hours to seconds
                    description,
                    locations: [{ type: 'inPerson', address: pkg.location || 'Toronto, ON' }],
                    availability: {
                      days: pkg.availabilityDays
                        ? pkg.availabilityDays.map(day => dayMap[day] || 1)
                        : [1, 2, 3, 4, 5, 6], // Default to Mon-Sat
                      startTime: pkg.startTime || '10:00',
                      endTime: pkg.endTime || '22:00'
                    },
                    ...(pkg.price > 0 ? {
                      price: pkg.price * 100, // Convert to cents
                      currency: 'cad',
                      requiresPayment: true
                    } : {}),
                    metadata: {
                      bookingUrl: pkg.bookingUrl || '',
                      dateAdded: pkg.dateAdded || ''
                    },
                    tags: [
                      ...(pkg.eventType || []),
                      pkg.packageType || 'Bundle',
                      pkg.Sale === 'Y' ? 'On Sale' : '',
                      pkg.New === 'Y' ? 'New' : ''
                    ].filter(Boolean)
                  };

                  const slug = transformed.slug;
                  const eventTypeId = await getEventTypeId(slug);
                  const method = eventTypeId ? 'PUT' : 'POST';
                  const path = eventTypeId ? \`/v2/event-types/\${eventTypeId}\` : '/v2/event-types';
                  console.log('API call:', method, path);

                  const options = {
                    hostname: 'api.cal.com',
                    path,
                    method,
                    headers: {
                      'Authorization': 'Bearer ' + process.env.CALCOM_API_KEY,
                      'Content-Type': 'application/json'
                    }
                  };

                  const response = await new Promise((resolve, reject) => {
                    const req = https.request(options, (res) => {
                      let data = '';
                      res.on('data', (chunk) => data += chunk);
                      res.on('end', () => resolve({ status: res.statusCode, data }));
                    });
                    req.on('error', (e) => reject(e));
                    req.write(JSON.stringify(transformed));
                    req.end();
                  });

                  if (response.status >= 200 && response.status < 300) {
                    console.log(\`Success for \${slug}: Status \${response.status}, Response: \${response.data}\`);
                  } else if (response.status === 400 && response.data.includes('event type with this slug')) {
                    console.warn(\`Warning: Skipped \${slug} due to duplicate slug. Consider updating manually or changing the slug.\`);
                  } else {
                    console.error(\`Failed for \${slug}: Status \${response.status}, Response: \${response.data}\`);
                    process.exit(1);
                  }

                  // Delay to avoid rate limiting
                  await new Promise(resolve => setTimeout(resolve, 1000));
                }
              } catch (e) {
                console.error('Error processing events:', e.message);
                process.exit(1);
              }
            }

            processEvents().catch(console.error);
          EOF
